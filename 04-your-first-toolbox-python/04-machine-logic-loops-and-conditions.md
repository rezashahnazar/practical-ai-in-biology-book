[← بخش ۴-۳: کار با رشته‌ها: تحلیل توالی‌های DNA و پروتئین](./03-working-with-strings-dna-sequences.md) | [بخش ۴-۵: پروژه: محاسبه محتوای GC →](./05-project-gc-content-calculation.md)

# فصل ۴: اولین جعبه ابزار شما: پایتون

## بخش ۴-۴: منطق زیستی در کد: حلقه‌ها (Loops) و دستورات شرطی (Conditional Statements)

تا اینجا، ما یاد گرفتیم که چگونه داده‌ها را ذخیره و دستکاری کنیم. اما قدرت واقعی برنامه‌نویسی زمانی آشکار می‌شود که بتوانیم بر اساس این داده‌ها **تصمیم‌گیری** کنیم و **کارهای تکراری** را به صورت خودکار انجام دهیم. این دو قابلیت، که به ترتیب با **دستورات شرطی (Conditional Statements)** و **حلقه‌ها (Loops)** ممکن می‌شوند، سنگ بنای هر الگوریتم هوشمندی هستند.

### 🎯 مسئله محوری: چگونه به کامپیوتر "قدرت تصمیم‌گیری" و "حوصله" برای کارهای تکراری را بدهیم؟

یک زیست‌شناس در آزمایشگاه دائماً در حال تصمیم‌گیری است ("اگر این ژن بیان شد، پس سلول سرطانی است") و کارهای تکراری انجام می‌دهد (بررسی هزاران تصویر میکروسکوپی). اما کامپیوتر، به خودی خود، نه قدرت قضاوت دارد و نه حوصله. چگونه می‌توانیم این دو قابلیت کلیدی انسانی را به ماشین منتقل کنیم؟ چگونه می‌توانیم کدی بنویسیم که بر اساس داده‌ها (مثلاً درصد GC یک توالی) یک نتیجه‌گیری منطقی کند؟ و چگونه می‌توانیم کامپیوتر را وادار کنیم تا یک دستورالعمل را میلیون‌ها بار بدون خستگی تکرار کند (مثلاً پیمایش یک ژنوم کامل)؟ در این بخش، ما با حلقه‌ها و دستورات شرطی، به کامپیوتر قدرت استدلال و استقامت می‌بخشیم.

---

### تصمیم‌گیری با `if`, `elif`, و `else`

در زیست‌شناسی، فرآیندهای زیادی به شرایط خاصی بستگی دارند. یک سلول تنها **اگر** (if) سیگنال رشد را دریافت کند، تقسیم می‌شود. یک آنزیم تنها **اگر** در pH مناسب باشد، به درستی کار می‌کند.

در پایتون، ما با استفاده از دستور `if` دقیقاً همین کار را انجام می‌دهیم. ما یک شرط را بررسی می‌کنیم و **اگر** آن شرط درست (`True`) بود، یک قطعه کد خاص را اجرا می‌کنیم.

بیایید یک مثال زیستی را بررسی کنیم: تشخیص یک ناحیه غنی از GC. نواحی پروموتری در ژنوم معمولاً درصد GC بالایی دارند. فرض کنیم اگر درصد GC یک توالی بالای ۶۰٪ باشد، آن را "GC-rich" می‌نامیم.

```python
# یک توالی فرضی
dna = "ATGCGCGCGATTAG"

# محاسبه درصد GC
g_count = dna.count('G')
c_count = dna.count('C')
gc_content = (g_count + c_count) / len(dna)

print(f"درصد GC: {gc_content:.2f}")

# حالا تصمیم‌گیری می‌کنیم
if gc_content > 0.6:
  print("این توالی غنی از GC است (GC-rich).")
elif gc_content < 0.4:
  print("این توالی غنی از AT است (AT-rich).")
else:
  print("این توالی درصد GC متوسطی دارد.")
```

**نکات مهم:**

- بعد از شرط در `if` و `elif` و بعد از `else`، حتماً علامت دو نقطه (`:`) قرار می‌گیرد.
- کدی که قرار است در صورت درست بودن شرط اجرا شود، باید با یک **تورفتگی (Indentation)** نوشته شود (معمولاً ۴ فاصله). این تورفتگی به پایتون می‌گوید که این کد متعلق به بلوک شرطی است.
- `elif` مخفف "else if" است و به ما اجازه می‌دهد چندین شرط را پشت سر هم بررسی کنیم.
- `else` زمانی اجرا می‌شود که هیچ‌کدام از شرط‌های `if` یا `elif` برقرار نباشند.
- عملگرهای مقایسه‌ای کلیدی: `>` (بزرگتر)، `<` (کوچکتر)، `==` (برابر با)، `!=` (نابرابر با). **دقت کنید که برای مقایسه برابری از `==` استفاده می‌شود، نه `=` که برای تخصیص متغیر است.**

### کارهای تکراری با حلقه‌ها (`for`)

تصور کنید می‌خواهید در یک توالی DNA به طول ۳ میلیارد باز، تمام بازها را یکی‌یکی بررسی کنید. نوشتن کد برای هر باز به صورت جداگانه غیرممکن است. اینجا جایی است که **حلقه‌ها** به کمک ما می‌آیند.

قوی‌ترین آنالوگ برای یک حلقه `for`، حرکت **ریبوزوم بر روی mRNA** است. ریبوزوم به ابتدای رشته متصل می‌شود، یک کدون را می‌خواند و پردازش می‌کند، سپس به کدون بعدی می‌رود و این کار را تا رسیدن به کدون پایان تکرار می‌کند.

یک حلقه `for` در پایتون دقیقاً همین کار را می‌کند. این حلقه به ما اجازه می‌دهد تا بر روی تک‌تک آیتم‌های یک مجموعه (مانند کاراکترهای یک رشته) حرکت کنیم و یک عملیات مشخص را برای هر آیتم انجام دهیم.

بیایید تمام بازهای یک توالی را یکی‌یکی چاپ کنیم:

```python
dna = "AGTC"

# برای هر "باز" در توالی "dna"
for base in dna:
  # این کد برای هر باز به صورت جداگانه اجرا می‌شود
  print("باز فعلی:", base)

print("پایان حلقه!")
```

**خروجی:**
`باز فعلی: A`
`باز فعلی: G`
`باز فعلی: T`
`باز فعلی: C`
`پایان حلقه!`

حالا یک مثال قدرتمندتر را ببینیم: شمارش باز 'G' با استفاده از حلقه و شرط. این کاری است که قبلاً با `.count()` انجام دادیم، اما حالا می‌خواهیم منطق آن را خودمان پیاده‌سازی کنیم.

```python
dna = "AGGTCCGATAAGCTTAGGAT"
g_counter = 0 # یک شمارنده برای ذخیره تعداد G ها

# برای هر باز در توالی dna
for base in dna:
  # آیا باز فعلی برابر با 'G' است؟
  if base == 'G':
    # اگر بله، یکی به شمارنده اضافه کن
    g_counter = g_counter + 1

# پس از پایان حلقه، نتیجه را چاپ کن
print("تعداد نهایی گوانین:", g_counter)
```

**خروجی:**
`تعداد نهایی گوانین: 6`

این الگو (یک حلقه برای پیمایش و یک دستور `if` برای تصمیم‌گیری در هر مرحله) یکی از بنیادی‌ترین و قدرتمندترین الگوها در تمام برنامه‌نویسی است.

---

### 🔬 تمرین تحلیلی: پیدا کردن کدون شروع

کدون شروع (Start Codon) که معمولاً `ATG` است، به ریبوزوم می‌گوید که از کجا ترجمه پروتئین را آغاز کند. شما باید کدی بنویسید که یک توالی DNA را حرف به حرف بررسی کند و به محض پیدا کردن اولین کدون `ATG`، پیام موفقیت را چاپ کرده و از حلقه خارج شود. اگر کل توالی بررسی شد و کدون شروعی پیدا نشد، باید پیام مناسبی چاپ شود.

**توالی برای آزمایش:** `GGACAGCATGAGGATTGCA`

**راهنمایی:**

- شما می‌توانید با slicing، در هر مرحله از حلقه یک قطعه سه حرفی (`dna[i:i+3]`) را بررسی کنید.
- برای خروج فوری از حلقه پس از پیدا کردن پاسخ، از دستور `break` استفاده کنید.

**پاسخ و راه حل:**

```python
dna = "GGACAGCATGAGGATTGCA"
found = False # یک پرچم برای اینکه بدانیم آیا کدون پیدا شده یا نه

# ما باید تا سه کاراکتر مانده به آخر حلقه بزنیم
for i in range(len(dna) - 2):
  codon = dna[i:i+3]
  if codon == "ATG":
    print(f"کدون شروع 'ATG' در ایندکس {i} پیدا شد.")
    found = True
    break # از حلقه خارج شو

# پس از پایان حلقه، بررسی کن که آیا پرچم تغییر کرده یا نه
if not found:
  print("کدون شروع در این توالی پیدا نشد.")

```

### 💡 نکات کلیدی این بخش

- **دستورات شرطی (`if`, `elif`, `else`)** به کد شما قدرت تصمیم‌گیری بر اساس درست یا غلط بودن یک شرط را می‌دهند.
- **حلقه‌ها (Loops)** مانند `for` برای تکرار یک سری از دستورات بر روی تمام اعضای یک مجموعه (مانند یک رشته) به کار می‌روند.
- **تورفتگی (Indentation)** برای مشخص کردن بلوک‌های کد در پایتون حیاتی است.
- ترکیب یک **حلقه** برای پیمایش داده و یک **شرط** برای تحلیل هر قطعه از داده، یک الگوی بنیادین در بیوانفورماتیک است.

با ترکیب حلقه‌ها و دستورات شرطی، شما می‌توانید تقریباً هر الگوریتم بیوانفورماتیکی را پیاده‌سازی کنید. در بخش بعدی، ما تمام این مهارت‌ها را در یک پروژه کوچک و عملی ترکیب خواهیم کرد.

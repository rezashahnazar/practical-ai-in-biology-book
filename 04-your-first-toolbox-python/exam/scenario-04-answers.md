[→ سناریو ۴: سوالات](./scenario-04-questions.md) | [فصل ۵: مقدمه ←](../05-building-first-prediction-models/00-introduction.md)

# آزمون فصل ۴: سناریو ۴ - پاسخنامه و تحلیل (یابنده جایگاه اتصال)

این بخش، کد کامل و توضیحات گام به گام برای مسئله "یابنده موتیف" را ارائه می‌دهد. این تمرین بر یکی از مهم‌ترین مهارت‌های کار با توالی‌ها، یعنی جستجوی مبتنی بر ایندکس و اسلایسینگ، تمرکز دارد.

### کد کامل راه‌حل

```python
# تعریف داده‌های ورودی
genomic_sequence = "GATATATAGATATAGATATACCCGATATAGATATAG"
motif = "GATA"

# -----------------------------------------------------
# قدم ۱: مقداردهی اولیه
# -----------------------------------------------------
# یک لیست خالی برای ذخیره ایندکس‌های پیدا شده
found_positions = []
len_motif = len(motif)
len_sequence = len(genomic_sequence)

# -----------------------------------------------------
# قدم ۲: حلقه جستجو
# -----------------------------------------------------
# ما باید تا جایی در توالی ژنومی پیش برویم که هنوز به اندازه طول موتیف، کاراکتر باقی مانده باشد
for i in range(len_sequence - len_motif + 1):
    # یک "پنجره" یا "برش" از توالی ژنومی به طول موتیف جدا می‌کنیم
    # این پنجره از ایندکس i شروع شده و به طول len_motif ادامه دارد
    current_window = genomic_sequence[i : i + len_motif]

    # بررسی می‌کنیم که آیا پنجره فعلی با موتیف ما برابر است یا خیر
    if current_window == motif:
        # اگر برابر بود، ایندکس شروع (i) را به لیست خود اضافه می‌کنیم
        found_positions.append(i)

# -----------------------------------------------------
# قدم ۳: گزارش نتایج
# -----------------------------------------------------
print(f"توالی در حال جستجو: {genomic_sequence}")
print(f"موتیف هدف: {motif}\n")

# تعداد موتیف‌های پیدا شده برابر با طول لیست ماست
match_count = len(found_positions)
print(f"موتیف '{motif}' {match_count} بار پیدا شد.")
print(f"موقعیت‌های شروع (ایندکس): {found_positions}")

```

### تحلیل و توضیح کد

#### قدم ۱: مقداردهی اولیه

- `found_positions = []`: ما یک لیست خالی برای جمع‌آوری نتایج ایجاد می‌کنیم. هر بار که موتیف را پیدا کنیم، ایندکس آن را به این لیست اضافه خواهیم کرد.
- `len_motif` و `len_sequence`: ما طول موتیف و توالی را در متغیرهایی ذخیره می‌کنیم. این کار باعث خواناتر شدن کد در حلقه می‌شود و از فراخوانی مکرر تابع `len()` جلوگیری می‌کند (یک بهینه‌سازی جزئی).

#### قدم ۲: حلقه جستجو (مهم‌ترین بخش)

- **`for i in range(len_sequence - len_motif + 1):`**: این خط، هسته منطقی الگوریتم ماست و درک آن بسیار مهم است.
  - چرا `len_sequence` خالی کافی نیست؟ چون اگر حلقه تا آخرین ایندکس توالی برود، هنگام تلاش برای برش دادن یک زیررشته به طول موتیف، از انتهای رشته خارج شده و با خطا مواجه می‌شویم (`IndexError`).
  - **چرا `len_sequence - len_motif + 1`؟** فرض کنید توالی ما ۱۰ کاراکتر و موتیف ۴ کاراکتر باشد. آخرین مکان ممکنی که موتیف می‌تواند از آنجا شروع شود، ایندکس ۶ است (`[6:10]`). `10 - 4 + 1 = 7`. تابع `range(7)` اعداد ۰ تا ۶ را تولید می‌کند که دقیقاً همان چیزی است که ما نیاز داریم. این فرمول، آخرین ایندکس شروع ممکن را به درستی محاسبه می‌کند.
- **`current_window = genomic_sequence[i : i + len_motif]`**: در هر تکرار حلقه، `i` ایندکس شروع پنجره ماست. ما یک برش از توالی ژنومی ایجاد می‌کنیم که از ایندکس `i` شروع شده و به اندازه طول موتیف (`len_motif`) ادامه دارد.
- **`if current_window == motif:`**: این شرط به سادگی بررسی می‌کند که آیا زیررشته‌ای که ما برش داده‌ایم، دقیقاً با موتیف هدف ما یکسان است یا خیر.
- **`found_positions.append(i)`**: اگر شرط برقرار باشد، یعنی ما یک تطابق پیدا کرده‌ایم. بنابراین، ایندکس شروع این تطابق (`i`) را با استفاده از متد `.append()` به انتهای لیست نتایج خود اضافه می‌کنیم.

#### قدم ۳: گزارش نتایج

- پس از پایان حلقه، لیست `found_positions` حاوی تمام ایندکس‌هایی است که موتیف در آن‌ها پیدا شده است.
- `match_count = len(found_positions)`: تعداد کل تطابق‌ها به سادگی برابر با تعداد اعضای (طول) لیست ماست.
- در نهایت، با استفاده از f-string ها، یک گزارش خلاصه و خوانا شامل تعداد تکرارها و لیست کامل موقعیت‌ها را چاپ می‌کنیم.

این الگوریتم یک روش کلاسیک و کارآمد برای جستجوی زیررشته است و اساس بسیاری از ابزارهای پیچیده‌تر در بیوانفورماتیک را تشکیل می‌دهد.

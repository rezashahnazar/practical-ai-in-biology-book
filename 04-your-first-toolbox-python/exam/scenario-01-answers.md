[→ سناریو ۱: سوالات](./scenario-01-questions.md) | [سناریو ۲: سوالات ←](./scenario-02-questions.md)

# آزمون فصل ۴: سناریو ۱ - پاسخنامه و تحلیل (تحلیلگر توالی DNA)

در این بخش، کد کامل برای حل مسئله تحلیلگر توالی DNA به همراه توضیحات گام به گام ارائه می‌شود. هدف این است که شما با منطق پشت هر بخش از کد آشنا شوید و ببینید چگونه مفاهیم فصل برای حل یک مسئله واقعی به کار گرفته شده‌اند.

### کد کامل راه‌حل

```python
# تعریف توالی ورودی
dna_sequence = "AGCTCCGTACGTNNAGCTAGCTANNNGCTACGATCAGCTNNACGATCGATCGATGC"

# -----------------------------------------------------
# قدم ۱: مقداردهی اولیه متغیرها
# -----------------------------------------------------
# شمارنده‌ها برای هر باز
count_a = 0
count_c = 0
count_g = 0
count_t = 0

# شمارنده برای کاراکترهای نامعتبر
invalid_chars_count = 0

# -----------------------------------------------------
# قدم ۲: پیمایش و پردازش توالی
# -----------------------------------------------------
# با یک حلقه for، بر روی هر کاراکتر (باز) در رشته حرکت می‌کنیم
for base in dna_sequence.upper(): # استفاده از .upper() برای نادیده گرفتن بزرگی و کوچکی حروف
    if base == 'A':
        count_a += 1
    elif base == 'C':
        count_c += 1
    elif base == 'G':
        count_g += 1
    elif base == 'T':
        count_t += 1
    else:
        # اگر کاراکتر هیچ‌کدام از بازهای معتبر نبود، آن را نامعتبر در نظر می‌گیریم
        invalid_chars_count += 1

# -----------------------------------------------------
# قدم ۳: انجام محاسبات نهایی
# -----------------------------------------------------
# محاسبه تعداد کل بازهای G و C
gc_count = count_g + count_c

# محاسبه طول کل توالی اصلی
total_length = len(dna_sequence)

# محاسبه طول معتبر توالی (بدون کاراکترهای نامعتبر)
valid_length = total_length - invalid_chars_count

# محاسبه درصد GC
# یک شرط برای جلوگیری از خطای تقسیم بر صفر در صورتی که توالی کاملا خالی یا نامعتبر باشد
if valid_length > 0:
    gc_percentage = (gc_count / valid_length) * 100
else:
    gc_percentage = 0

# -----------------------------------------------------
# قدم ۴: چاپ خروجی در فرمت خواسته‌شده
# -----------------------------------------------------
print(f"توالی تحت بررسی: {dna_sequence}\n")

print("--- گزارش اعتبارسنجی ---")
if invalid_chars_count > 0:
    print(f"هشدار: {invalid_chars_count} کاراکتر نامعتبر در توالی پیدا شد.")
else:
    print("توالی کاملا معتبر است.")

print("\n--- تحلیل آماری ---")
print("تعداد بازها:")
print(f"A: {count_a}")
print(f"C: {count_c}")
print(f"G: {count_g}")
print(f"T: {count_t}")

print(f"\nطول توالی معتبر: {valid_length} باز")
# استفاده از f-string برای فرمت‌دهی درصد با دو رقم اعشار
print(f"درصد GC محتوا: {gc_percentage:.2f} %")

```

### تحلیل و توضیح کد

#### قدم ۱: مقداردهی اولیه متغیرها

- قبل از شروع هرگونه شمارش، ما نیاز به متغیرهایی داریم که نتایج را در خود ذخیره کنند.
- `count_a`, `count_c`, `count_g`, `count_t`: هر کدام از این متغیرها برای نگهداری تعداد یکی از بازهای نوکلئوتیدی تعریف شده و با صفر مقداردهی اولیه می‌شوند.
- `invalid_chars_count`: این متغیر برای شمارش کاراکترهایی که A, T, C, یا G نیستند، استفاده می‌شود.

#### قدم ۲: پیمایش و پردازش توالی

- قلب برنامه ما یک حلقه `for` است که روی تمام کاراکترهای رشته `dna_sequence` حرکت می‌کند.
- `dna_sequence.upper()`: ما قبل از ورود به حلقه، کل رشته را به حروف بزرگ تبدیل می‌کنیم. این یک تکنیک رایج و هوشمندانه برای **نادیده گرفتن بزرگی و کوچکی حروف** است. با این کار، دیگر نیازی نیست در دستورات شرطی خود هم `a` و هم `A` را بررسی کنیم؛ فقط بررسی `A` کافی است.
- **بلوک `if/elif/else`:** این بلوک، منطق اصلی دسته‌بندی هر کاراکتر است.
  - `if base == 'A'`: اگر کاراکتر 'A' بود، شمارنده مربوط به آن یک واحد زیاد می‌شود (`count_a += 1`).
  - `elif`: به همین ترتیب برای C, G, T نیز شمارنده‌های خودشان افزایش می‌یابند.
  - `else`: این بخش بسیار مهم است. اگر کاراکتری که در حال بررسی آن هستیم، هیچ‌کدام از گزینه‌های `if` یا `elif` نبود، به این معنی است که یک کاراکتر نامعتبر است. بنابراین، شمارنده `invalid_chars_count` یک واحد افزایش می‌یابد.

#### قدم ۳: انجام محاسبات نهایی

- پس از اینکه حلقه به پایان رسید و تمام کاراکترها پردازش شدند، ما تمام اطلاعات مورد نیاز برای محاسبات نهایی را در متغیرهای شمارنده خود داریم.
- `gc_count`: تعداد کل بازهای G و C را با جمع کردن شمارنده‌های مربوطه به دست می‌آوریم.
- `valid_length`: این مهم‌ترین بخش محاسبه است. ما نمی‌توانیم از `len(dna_sequence)` برای محاسبه درصد GC استفاده کنیم، زیرا این طول شامل کاراکترهای نامعتبر نیز می‌شود. بنابراین، طول معتبر را با کم کردن تعداد کاراکترهای نامعتبر از طول کل رشته به دست می‌آوریم.
- `gc_percentage`: درصد GC با تقسیم `gc_count` بر `valid_length` و ضرب در ۱۰۰ محاسبه می‌شود.
- **شرط `if valid_length > 0`:** این یک اقدام احتیاطی و نشانه کدنویسی خوب است. اگر رشته ورودی کاملاً خالی یا متشکل از کاراکترهای نامعتبر باشد، `valid_length` صفر خواهد بود و تلاش برای تقسیم بر آن باعث بروز خطا (`ZeroDivisionError`) می‌شود. این شرط از وقوع چنین خطایی جلوگیری می‌کند.

#### قدم ۴: چاپ خروجی

- در این مرحله، فقط نتایج را با استفاده از `print` و **f-string** ها نمایش می‌دهیم.
- `\n`: از این کاراکتر برای ایجاد یک خط خالی و جداسازی بخش‌های مختلف خروجی استفاده شده است.
- `{gc_percentage:.2f}`: این یک ویژگی قدرتمند در f-string هاست. بخش `:.2f` به پایتون می‌گوید که متغیر `gc_percentage` را به صورت یک عدد اعشاری (float) و **فقط با دو رقم بعد از ممیز** نمایش بده. این کار فرمت خروجی را دقیقاً مطابق با آنچه در صورت سوال خواسته شده بود، تنظیم می‌کند.
- همچنین یک دستور `if` برای چاپ پیام مناسب در بخش اعتبارسنجی (بسته به اینکه کاراکتر نامعتبری پیدا شده یا نه) استفاده شده است.
